Hi everyone.
Today we'll talk about collapsing merge tree
This is an interesting engine. At my place we used it because at some point CH didn't support updates
And for one of our tables it sort of made sense.
We still use it, but we would've done it without it now.

Still I think It's important to talk about it, since there are use cases for it that
you might encounter.

Let's start by creating a table

create database collapsing_merge_tree;

CREATE TABLE collapsing_merge_tree.pokemon_age
(
    pokemon_id UInt64,
    age UInt8,
    health String,
    sign Int8 DEFAULT 1
)
ENGINE = CollapsingMergeTree(sign)
ORDER BY pokemon_id

I strongly suggest using default value for sign, if you insert
any other value instead of -1 or 1, you will see pretty ugly error in logs
and CH won't be able to ever collapse the table

Let's now try to inset. Clickhouse docs sugget this way.
You need to cancel and remember previous state. Ok lets see what happens


INSERT INTO collapsing_merge_tree.pokemon_age VALUES (1, 1, 'good', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (1, 1, 'good', -1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (1, 2, 'mhe', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (1, 5, 'mhe', -1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (1, 6, 'mhe mhe', 1);

lets test our table
and there are 2 ways

SELECT
    pokemon_id,
    sum(age * sign) AS age,
    anyLast(health) as health
FROM collapsing_merge_tree.pokemon_age
GROUP BY pokemon_id
HAVING sum(sign) > 0

SELECT * FROM pokemon_age FINAL

But now you can also insert values like this and as far as I can tell it will still work

INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 1, 'awesome', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 2, 'still awesome', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 3, 'getting old', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 4, 'awesome again', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 5, 'now rally super old', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 6, 'ready', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 7, 'I want to live', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 8, 'I want to live so much', 1);
INSERT INTO collapsing_merge_tree.pokemon_age VALUES (10, 9, 'yep, ready', 1);

and if you execute
SELECT * FROM pokemon_age FINAL
you'll see correct results,

ok so ch documentation has pretty good overview and explanation of this topic
There's also additional link attached with some more discussion on the topic

So why use it?
If you have some entity that changes all the time, but you don't have time to wait for data writes.
Merge tree will make sure data is changed, but perform expensive i/o operation only a few times
to save you on server cost.